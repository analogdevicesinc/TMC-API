/*******************************************************************************
* Copyright © 2019 TRINAMIC Motion Control GmbH & Co. KG
* (now owned by Analog Devices Inc.),
*
* Copyright © 2024 Analog Devices Inc. All Rights Reserved.
* This software is proprietary to Analog Devices, Inc. and its licensors.
*******************************************************************************/

#include "MAX22216.h"

#ifdef TMC_API_EXTERNAL_CRC_TABLE
extern const uint8_t tmcCRCTable_Poly110101[256];
#else
const uint8_t tmcCRCTable_Poly110101[256] = {
        0x00, 0x16, 0x19, 0x0F, 0x07, 0x11, 0x1E, 0x08, 0x0E, 0x18, 0x17, 0x01, 0x09, 0x1F, 0x10, 0x06,
        0x1C, 0x0A, 0x05, 0x13, 0x1B, 0x0D, 0x02, 0x14, 0x12, 0x04, 0x0B, 0x1D, 0x15, 0x03, 0x0C, 0x1A,
        0x0D, 0x1B, 0x14, 0x02, 0x0A, 0x1C, 0x13, 0x05, 0x03, 0x15, 0x1A, 0x0C, 0x04, 0x12, 0x1D, 0x0B,
        0x11, 0x07, 0x08, 0x1E, 0x16, 0x00, 0x0F, 0x19, 0x1F, 0x09, 0x06, 0x10, 0x18, 0x0E, 0x01, 0x17,
        0x1A, 0x0C, 0x03, 0x15, 0x1D, 0x0B, 0x04, 0x12, 0x14, 0x02, 0x0D, 0x1B, 0x13, 0x05, 0x0A, 0x1C,
        0x06, 0x10, 0x1F, 0x09, 0x01, 0x17, 0x18, 0x0E, 0x08, 0x1E, 0x11, 0x07, 0x0F, 0x19, 0x16, 0x00,
        0x17, 0x01, 0x0E, 0x18, 0x10, 0x06, 0x09, 0x1F, 0x19, 0x0F, 0x00, 0x16, 0x1E, 0x08, 0x07, 0x11,
        0x0B, 0x1D, 0x12, 0x04, 0x0C, 0x1A, 0x15, 0x03, 0x05, 0x13, 0x1C, 0x0A, 0x02, 0x14, 0x1B, 0x0D,
        0x01, 0x17, 0x18, 0x0E, 0x06, 0x10, 0x1F, 0x09, 0x0F, 0x19, 0x16, 0x00, 0x08, 0x1E, 0x11, 0x07,
        0x1D, 0x0B, 0x04, 0x12, 0x1A, 0x0C, 0x03, 0x15, 0x13, 0x05, 0x0A, 0x1C, 0x14, 0x02, 0x0D, 0x1B,
        0x0C, 0x1A, 0x15, 0x03, 0x0B, 0x1D, 0x12, 0x04, 0x02, 0x14, 0x1B, 0x0D, 0x05, 0x13, 0x1C, 0x0A,
        0x10, 0x06, 0x09, 0x1F, 0x17, 0x01, 0x0E, 0x18, 0x1E, 0x08, 0x07, 0x11, 0x19, 0x0F, 0x00, 0x16,
        0x1B, 0x0D, 0x02, 0x14, 0x1C, 0x0A, 0x05, 0x13, 0x15, 0x03, 0x0C, 0x1A, 0x12, 0x04, 0x0B, 0x1D,
        0x07, 0x11, 0x1E, 0x08, 0x00, 0x16, 0x19, 0x0F, 0x09, 0x1F, 0x10, 0x06, 0x0E, 0x18, 0x17, 0x01,
        0x16, 0x00, 0x0F, 0x19, 0x11, 0x07, 0x08, 0x1E, 0x18, 0x0E, 0x01, 0x17, 0x1F, 0x09, 0x06, 0x10,
        0x0A, 0x1C, 0x13, 0x05, 0x0D, 0x1B, 0x14, 0x02, 0x04, 0x12, 0x1D, 0x0B, 0x03, 0x15, 0x1A, 0x0C,
};
#endif

static uint16_t readRegisterSPI(uint16_t icID, uint8_t address);
static uint16_t readRegisterSPI_CRC_EN(uint16_t icID, uint8_t address);
static void writeRegisterSPI(uint16_t icID, uint8_t address, uint16_t value);
static void writeRegisterSPI_CRC_EN(uint16_t icID, uint8_t address, uint16_t value);

uint16_t max22216_readRegister(uint16_t icID, uint8_t address)
{
    if (max22216_getCRCEnState())
    {
        return readRegisterSPI_CRC_EN(icID, address);
    }
    else
    {
        return readRegisterSPI(icID, address);
    }
}

void max22216_writeRegister(uint16_t icID, uint8_t address, uint16_t value)
{
    if (max22216_getCRCEnState())
    {
        writeRegisterSPI_CRC_EN(icID, address, value);
    }
    else
    {
        writeRegisterSPI(icID, address, value);
    }
}

uint16_t readRegisterSPI_CRC_EN(uint16_t icID, uint8_t address)
{
    uint8_t data[4] = {0};

    // clear write bit
    data[0] = address & MAX22216_ADDRESS_MASK;

    // Generate the CRC value for comparison
    data[3] = max22216_CRC(&data[0], 3);

    // Send the read request
    max22216_readWriteSPI(icID, &data[0], sizeof(data));

    // Rewrite address and clear write bit
    data[0] = address & MAX22216_ADDRESS_MASK;

    // Generate the CRC value for comparison
    data[3] = max22216_CRC(&data[0], 3);

    // Send another request to receive the read reply
    max22216_readWriteSPI(icID, &data[0], sizeof(data));

    return ((uint16_t) data[1] << 8) | ((uint16_t) data[2]);
}

uint16_t readRegisterSPI(uint16_t icID, uint8_t address)
{
    uint8_t data[3] = {0};

    // clear write bit
    data[0] = address & MAX22216_ADDRESS_MASK;

    // Send the read request
    max22216_readWriteSPI(icID, &data[0], sizeof(data));

    // Rewrite address and clear write bit
    data[0] = address & MAX22216_ADDRESS_MASK;

    // Send another request to receive the read reply
    max22216_readWriteSPI(icID, &data[0], sizeof(data));

    return ((uint16_t) data[1] << 8) | ((uint16_t) data[2]);
}

void writeRegisterSPI_CRC_EN(uint16_t icID, uint8_t address, uint16_t value)
{
    uint8_t data[4] = {0};

    data[0] = address | MAX22216_WRITE_BIT;
    data[1] = ((value >> 8) & 0xFF);
    data[2] = value & 0xFF;
    data[3] = max22216_CRC(&data[0], 3);

    // Send the write request
    max22216_readWriteSPI(icID, &data[0], sizeof(data));
}

void writeRegisterSPI(uint16_t icID, uint8_t address, uint16_t value)
{
    uint8_t data[3] = {0};

    data[0] = address | MAX22216_WRITE_BIT;
    data[1] = ((value >> 8) & 0xFF);
    data[2] = value & 0xFF;

    // Send the write request
    max22216_readWriteSPI(icID, &data[0], sizeof(data));
}

// length in bytes
uint8_t max22216_CRC(uint8_t *data, size_t length)
{
    uint8_t crc = 0b11111000;

    for (size_t i = 0; i < length; i++)
    {
        crc = tmcCRCTable_Poly110101[crc ^ data[i]];
    }
    return crc;
}
