/*******************************************************************************
* Copyright © 2019 TRINAMIC Motion Control GmbH & Co. KG
* (now owned by Analog Devices Inc.),
*
* Copyright © 2023 Analog Devices Inc. All Rights Reserved. This software is
* proprietary & confidential to Analog Devices, Inc. and its licensors.
*******************************************************************************/


#ifndef TMC2240_FIELDS_H
#define TMC2240_FIELDS_H

// Status fields returned with every SPI transaction
#define TMC2240_SPI_STATUS_RESET_FLAG_MASK          0x01 /* GSTAT[0] - 1: Signals, that a reset has occurred (clear by reading GSTAT) */
#define TMC2240_SPI_STATUS_RESET_FLAG_SHIFT         0
#define TMC2240_SPI_STATUS_DRIVER_ERROR_MASK        0x02 /* GSTAT[1] – 1: Signals driver 1 driver error (clear by reading GSTAT) */
#define TMC2240_SPI_STATUS_DRIVER_ERROR_SHIFT       1
#define TMC2240_SPI_STATUS_SG2_MASK                 0x04 /* DRV_STATUS[24] – 1: Signals StallGuard flag active */
#define TMC2240_SPI_STATUS_SG2_SHIFT                2
#define TMC2240_SPI_STATUS_STANDSTILL_MASK          0x08 /* DRV_STATUS[31] – 1: Signals motor stand still */
#define TMC2240_SPI_STATUS_STANDSTILL_SHIFT         3
#define TMC2240_SPI_STATUS_VELOCITY_REACHED_MASK    0x10 /* RAMP_STAT[8] – 1: Signals target velocity reached (motion controller only) */
#define TMC2240_SPI_STATUS_VELOCITY_REACHED_SHIFT   4
#define TMC2240_SPI_STATUS_POSITION_REACHED_MASK    0x20 /* RAMP_STAT[9] – 1: Signals target position reached (motion controller only) */
#define TMC2240_SPI_STATUS_POSITION_REACHED_SHIFT   5
#define TMC2240_SPI_STATUS_STATUS_STOP_L_MASK       0x40 /* RAMP_STAT[0] – 1: Signals stop left switch status (motion controller only) */
#define TMC2240_SPI_STATUS_STATUS_STOP_L_SHIFT      6
#define TMC2240_SPI_STATUS_STATUS_STOP_R_MASK       0x80 /* RAMP_STAT[1] – 1: Signals stop right switch status (motion controller only) */
#define TMC2240_SPI_STATUS_STATUS_STOP_R_SHIFT      7

// Configuration & status registers
/*
 *  2240.h
 *  Author: LK
 *  Generated by MaskShiftConverter (unchecked)
 */
#define TMC2240_FAST_STANDSTILL_MASK 0x02 // GCONF // Timeout for step execution until standstill detection
#define TMC2240_FAST_STANDSTILL_SHIFT 1 // Timeout for step execution until standstill detection
#define TMC2240_EN_PWM_MODE_MASK 0x04 // GCONF // Enable the stealthChop(TM) mode
#define TMC2240_EN_PWM_MODE_SHIFT 2 // Enable the stealthChop(TM) mode
#define TMC2240_MULTISTEP_FILT_MASK 0x08 // GCONF // Enable step input filtering for stealthChop
#define TMC2240_MULTISTEP_FILT_SHIFT 3 // Enable step input filtering for stealthChop
#define TMC2240_SHAFT_MASK 0x10 // GCONF // Change motor direction / direction sign
#define TMC2240_SHAFT_SHIFT 4 // Change motor direction / direction sign
#define TMC2240_DIAG0_ERROR_MASK 0x20 // GCONF // DIAG0 output configuration.; DIAG0 always shows the reset-status, i.e. is active low during reset condition.
#define TMC2240_DIAG0_ERROR_SHIFT 5 // DIAG0 output configuration.; DIAG0 always shows the reset-status, i.e. is active low during reset condition.
#define TMC2240_DIAG0_OTPW_MASK 0x40 // GCONF // DIAG0 output configuration.
#define TMC2240_DIAG0_OTPW_SHIFT 6 // DIAG0 output configuration.
#define TMC2240_DIAG0_STALL_MASK 0x80 // GCONF // DIAG0 output configuration.
#define TMC2240_DIAG0_STALL_SHIFT 7 // DIAG0 output configuration.
#define TMC2240_DIAG1_STALL_MASK 0x100 // GCONF // DIAG1 output configuration.
#define TMC2240_DIAG1_STALL_SHIFT 8 // DIAG1 output configuration.
#define TMC2240_DIAG1_INDEX_MASK 0x200 // GCONF // DIAG1 output configuration.
#define TMC2240_DIAG1_INDEX_SHIFT 9 // DIAG1 output configuration.
#define TMC2240_DIAG1_ONSTATE_MASK 0x400 // GCONF // DIAG1 output configuration.
#define TMC2240_DIAG1_ONSTATE_SHIFT 10 // DIAG1 output configuration.
#define TMC2240_DIAG0_PUSHPULL_MASK 0x1000 // GCONF // DIAG0 output type configuration.
#define TMC2240_DIAG0_PUSHPULL_SHIFT 12 // DIAG0 output type configuration.
#define TMC2240_DIAG1_PUSHPULL_MASK 0x2000 // GCONF // DIAG1 output type configuration.
#define TMC2240_DIAG1_PUSHPULL_SHIFT 13 // DIAG1 output type configuration.
#define TMC2240_SMALL_HYSTERESIS_MASK 0x4000 // GCONF // SMALL_HYSTERESIS
#define TMC2240_SMALL_HYSTERESIS_SHIFT 14 // SMALL_HYSTERESIS
#define TMC2240_STOP_ENABLE_MASK 0x8000 // GCONF // Motor hard stop function enable.
#define TMC2240_STOP_ENABLE_SHIFT 15 // Motor hard stop function enable.
#define TMC2240_DIRECT_MODE_MASK 0x10000 // GCONF // Enable direct motor phase current control via serial interface.
#define TMC2240_DIRECT_MODE_SHIFT 16 // Enable direct motor phase current control via serial interface.
#define TMC2240_RESET_MASK 0x01 // GSTAT // Reset flag#type=COW
#define TMC2240_RESET_SHIFT 0 // Reset flag#type=COW
#define TMC2240_DRV_ERR_MASK 0x02 // GSTAT // Driver error flag#type=COW
#define TMC2240_DRV_ERR_SHIFT 1 // Driver error flag#type=COW
#define TMC2240_UV_CP_MASK 0x04 // GSTAT // Charge pump undervoltage condition flag#type=COW
#define TMC2240_UV_CP_SHIFT 2 // Charge pump undervoltage condition flag#type=COW
#define TMC2240_REGISTER_RESET_MASK 0x08 // GSTAT // REGISTER_RESET
#define TMC2240_REGISTER_RESET_SHIFT 3 // REGISTER_RESET
#define TMC2240_VM_UVLO_MASK 0x10 // GSTAT // 1: VM undervoltage has occured since last reset.
#define TMC2240_VM_UVLO_SHIFT 4 // 1: VM undervoltage has occured since last reset.
#define TMC2240_IFCNT_MASK 0xFF // IFCNT // Interface transmission counter. This register becomes incremented with each successful UART interface write access. It can be read out to check the serial transmission for lost data. Read accesses do not change the content. Disabled in SPI operation. The counter wraps around from 255 to 0.
#define TMC2240_IFCNT_SHIFT 0 // Interface transmission counter. This register becomes incremented with each successful UART interface write access. It can be read out to check the serial transmission for lost data. Read accesses do not change the content. Disabled in SPI operation. The counter wraps around from 255 to 0.
#define TMC2240_SLAVEADDR_MASK 0xFF // SLAVECONF // SLAVEADDR:; These eight bits set the address of unit for the UART interface. The address becomes incremented by one, two or three, as defined by SDI and SCK.; SCK, SDI; 00: +0; 01: +1; 10: +2; 11: +3; Range: 0-254 (do not increment beyond 254)
#define TMC2240_SLAVEADDR_SHIFT 0 // SLAVEADDR:; These eight bits set the address of unit for the UART interface. The address becomes incremented by one, two or three, as defined by SDI and SCK.; SCK, SDI; 00: +0; 01: +1; 10: +2; 11: +3; Range: 0-254 (do not increment beyond 254)
#define TMC2240_SENDDELAY_MASK 0xF00 // SLAVECONF // SWUART Slave Configuration
#define TMC2240_SENDDELAY_SHIFT 8 // SWUART Slave Configuration
#define TMC2240_REFL_STEP_MASK 0x01 // IOIN // REFL_STEP
#define TMC2240_REFL_STEP_SHIFT 0 // REFL_STEP
#define TMC2240_REFR_DIR_MASK 0x02 // IOIN // REFR_DIR
#define TMC2240_REFR_DIR_SHIFT 1 // REFR_DIR
#define TMC2240_ENCB_CFG4_MASK 0x04 // IOIN // B-channel state
#define TMC2240_ENCB_CFG4_SHIFT 2 // B-channel state
#define TMC2240_ENCA_CFG5_MASK 0x08 // IOIN // A-channel state
#define TMC2240_ENCA_CFG5_SHIFT 3 // A-channel state
#define TMC2240_DRV_ENN_MASK 0x10 // IOIN // Driver disabled/enabled state.
#define TMC2240_DRV_ENN_SHIFT 4 // Driver disabled/enabled state.
#define TMC2240_ENCN_CFG6_MASK 0x20 // IOIN // N-channel state
#define TMC2240_ENCN_CFG6_SHIFT 5 // N-channel state
#define TMC2240_UART_EN_MASK 0x40 // IOIN // 1 = UART interface is enabled
#define TMC2240_UART_EN_SHIFT 6 // 1 = UART interface is enabled
#define TMC2240_COMP_A_MASK 0x100 // IOIN // COMP_A (chopper comparator A, for IC test)
#define TMC2240_COMP_A_SHIFT 8 // COMP_A (chopper comparator A, for IC test)
#define TMC2240_COMP_B_MASK 0x200 // IOIN // COMP_B (chopper comparator B, for IC test)
#define TMC2240_COMP_B_SHIFT 9 // COMP_B (chopper comparator B, for IC test)
#define TMC2240_COMP_A1_A2_MASK 0x400 // IOIN // COMP_A1_A2 (StallGuard4 comparator A, for IC test)
#define TMC2240_COMP_A1_A2_SHIFT 10 // COMP_A1_A2 (StallGuard4 comparator A, for IC test)
#define TMC2240_COMP_B1_B2_MASK 0x800 // IOIN // COMP_B1_B2 (StallGuard4 comparator B, for IC test)
#define TMC2240_COMP_B1_B2_SHIFT 11 // COMP_B1_B2 (StallGuard4 comparator B, for IC test)
#define TMC2240_OUTPUT_MASK 0x1000 // IOIN // Output polarity of SDO_CFG0 pin when UART is enabled via pin UART_EN_CFG7. Its main purpose it to use SDO_CFG0 as NAO next address output signal for chain addressing of multiple ICs. Attention: Reset Value is 1 for use as NAO to next IC in single wire chain
#define TMC2240_OUTPUT_SHIFT 12 // Output polarity of SDO_CFG0 pin when UART is enabled via pin UART_EN_CFG7. Its main purpose it to use SDO_CFG0 as NAO next address output signal for chain addressing of multiple ICs. Attention: Reset Value is 1 for use as NAO to next IC in single wire chain
#define TMC2240_EXT_RES_DET_MASK 0x2000 // IOIN // 1: External resistor between REF and GND; 0: No external resistor detected
#define TMC2240_EXT_RES_DET_SHIFT 13 // 1: External resistor between REF and GND; 0: No external resistor detected
#define TMC2240_EXT_CLK_MASK 0x4000 // IOIN // 0: The internal oscillator is used for generating the clock-signal (12.5 MHz).; 1: The external oscillator is used for generating the clock-signal.
#define TMC2240_EXT_CLK_SHIFT 14 // 0: The internal oscillator is used for generating the clock-signal (12.5 MHz).; 1: The external oscillator is used for generating the clock-signal.
#define TMC2240_ADC_ERR_MASK 0x8000 // IOIN // 1: Signals that the ADC is not working correctly. Do not utilize ADC-features.Adc is stuck in configurationmode and very likely does not receive an ACK_OUT
#define TMC2240_ADC_ERR_SHIFT 15 // 1: Signals that the ADC is not working correctly. Do not utilize ADC-features.Adc is stuck in configurationmode and very likely does not receive an ACK_OUT
#define TMC2240_SILICON_RV_MASK 0x70000 // IOIN // Silicon revision number
#define TMC2240_SILICON_RV_SHIFT 16 // Silicon revision number
#define TMC2240_VERSION_MASK 0xFF000000 // IOIN // 0x40 = first version of the IC; Identical numbers mean full digital compatibility.
#define TMC2240_VERSION_SHIFT 24 // 0x40 = first version of the IC; Identical numbers mean full digital compatibility.
#define TMC2240_CURRENT_RANGE_MASK 0x03 // DRV_CONF // This setting allows a basic adaptation of the drivers RDSon current sensing to the motor current range. Select the lowest fitting range for best current precision. The value is the peak current setting.
#define TMC2240_CURRENT_RANGE_SHIFT 0 // This setting allows a basic adaptation of the drivers RDSon current sensing to the motor current range. Select the lowest fitting range for best current precision. The value is the peak current setting.
#define TMC2240_SLOPE_CONTROL_MASK 0x30 // DRV_CONF // Slope Control Setting
#define TMC2240_SLOPE_CONTROL_SHIFT 4 // Slope Control Setting
#define TMC2240_GLOBALSCALER_MASK 0xFF // GLOBAL_SCALER // Global scaling of Motor current. This value is multiplied to the current scaling in order to adapt a drive to a certain motor type. This value should be chosen before tuning other settings, because it also influences chopper hysteresis.; 0:; Full Scale (or write 256); 1 … 31:; Not allowed for operation; 32 … 255:; 32/256 … 255/256 of maximum current.; Hint: Values >128 recommended for best results
#define TMC2240_GLOBALSCALER_SHIFT 0 // Global scaling of Motor current. This value is multiplied to the current scaling in order to adapt a drive to a certain motor type. This value should be chosen before tuning other settings, because it also influences chopper hysteresis.; 0:; Full Scale (or write 256); 1 … 31:; Not allowed for operation; 32 … 255:; 32/256 … 255/256 of maximum current.; Hint: Values >128 recommended for best results
#define TMC2240_IHOLD_MASK 0x1F // IHOLD_IRUN // Standstill current (0=1/32…31=32/32); In combination with StealthChop mode, setting IHOLD=0 allows to choose freewheeling or coil short circuit for motor stand still.
#define TMC2240_IHOLD_SHIFT 0 // Standstill current (0=1/32…31=32/32); In combination with StealthChop mode, setting IHOLD=0 allows to choose freewheeling or coil short circuit for motor stand still.
#define TMC2240_IRUN_MASK 0x1F00 // IHOLD_IRUN // Motor run current (0=1/32…31=32/32); Hint: Choose sense resistors in a way, that normal IRUN is 16 to 31 for best microstep performance.
#define TMC2240_IRUN_SHIFT 8 // Motor run current (0=1/32…31=32/32); Hint: Choose sense resistors in a way, that normal IRUN is 16 to 31 for best microstep performance.
#define TMC2240_IHOLDDELAY_MASK 0xF0000 // IHOLD_IRUN // Controls the number of clock cycles for motor power down after a motion as soon as standstill is detected (stst=1) and TPOWERDOWN has expired. The smooth transition avoids a motor jerk upon power down.; 0:; instant power down; 1..15:; Delay per current reduction step in multiple of 2^18 clocks
#define TMC2240_IHOLDDELAY_SHIFT 16 // Controls the number of clock cycles for motor power down after a motion as soon as standstill is detected (stst=1) and TPOWERDOWN has expired. The smooth transition avoids a motor jerk upon power down.; 0:; instant power down; 1..15:; Delay per current reduction step in multiple of 2^18 clocks
#define TMC2240_IRUNDELAY_MASK 0xF000000 // IHOLD_IRUN // Controls the number of clock cycles for motor power up after start is detected. 0:; instant power up 1..15:; Delay per current increment step in multiple of IRUNDELAY * 512 clocks
#define TMC2240_IRUNDELAY_SHIFT 24 // Controls the number of clock cycles for motor power up after start is detected. 0:; instant power up 1..15:; Delay per current increment step in multiple of IRUNDELAY * 512 clocks
#define TMC2240_TPOWERDOWN_MASK 0xFF // TPOWERDOWN // TPOWERDOWN sets the delay time after stand still (stst) of the motor to motor current power down. Time range is about 0 to 4 seconds.; Attention: A minimum setting of 2 is required to allow automatic tuning of StealthChop PWM_OFFS_AUTO.; Reset Default = 10; 0…((2^8)-1) * 2^18 tCLK
#define TMC2240_TPOWERDOWN_SHIFT 0 // TPOWERDOWN sets the delay time after stand still (stst) of the motor to motor current power down. Time range is about 0 to 4 seconds.; Attention: A minimum setting of 2 is required to allow automatic tuning of StealthChop PWM_OFFS_AUTO.; Reset Default = 10; 0…((2^8)-1) * 2^18 tCLK
#define TMC2240_TSTEP_MASK 0xFFFFF // TSTEP // Actual measured time between two 1/256 microsteps derived from the step input frequency in units of 1/fCLK. Measured value is (2^20)-1 in case of overflow or stand still.; All TSTEP related thresholds use a hysteresis of 1/16 of the compare value to compensate for jitter in the clock or the step frequency. The flag small_hysteresis modifies the hysteresis to a smaller value of 1/32.; (Txxx*15/16)-1 or; (Txxx*31/32)-1 is used as a second compare value for each comparison value.; This means, that the lower switching velocity equals the calculated setting, but the upper switching velocity is higher as defined by the hysteresis setting.; When working with the motion controller, the measured TSTEP for a given velocity V is in the range; (224 / V) = TSTEP = 224 / V - 1.; In DcStep mode TSTEP will not show the mean velocity of the motor, but the velocities for each microstep, which may not be stable and thus does not represent the real motor velocity in case it runs slower than the target velocity.
#define TMC2240_TSTEP_SHIFT 0 // Actual measured time between two 1/256 microsteps derived from the step input frequency in units of 1/fCLK. Measured value is (2^20)-1 in case of overflow or stand still.; All TSTEP related thresholds use a hysteresis of 1/16 of the compare value to compensate for jitter in the clock or the step frequency. The flag small_hysteresis modifies the hysteresis to a smaller value of 1/32.; (Txxx*15/16)-1 or; (Txxx*31/32)-1 is used as a second compare value for each comparison value.; This means, that the lower switching velocity equals the calculated setting, but the upper switching velocity is higher as defined by the hysteresis setting.; When working with the motion controller, the measured TSTEP for a given velocity V is in the range; (224 / V) = TSTEP = 224 / V - 1.; In DcStep mode TSTEP will not show the mean velocity of the motor, but the velocities for each microstep, which may not be stable and thus does not represent the real motor velocity in case it runs slower than the target velocity.
#define TMC2240_TPWMTHRS_MASK 0xFFFFF // TPWMTHRS // This is the upper velocity for StealthChop voltage PWM mode.; TSTEP = TPWMTHRS; StealthChop PWM mode is enabled, if configured; DcStep is disabled
#define TMC2240_TPWMTHRS_SHIFT 0 // This is the upper velocity for StealthChop voltage PWM mode.; TSTEP = TPWMTHRS; StealthChop PWM mode is enabled, if configured; DcStep is disabled
#define TMC2240_TCOOLTHRS_MASK 0xFFFFF // TCOOLTHRS // This is the lower threshold velocity for switching on smart energy CoolStep and StallGuard feature. (unsigned); Set this parameter to disable CoolStep at low speeds, where it cannot work reliably. The stop on stall function (enable with sg_stop when using internal motion controller) and the stall output signal become enabled when exceeding this velocity. In non-DcStep mode, it becomes disabled again once the velocity falls below this threshold.; TCOOLTHRS = TSTEP = THIGH:; CoolStep is enabled, if configured; TCOOLTHRS = TSTEP; Stop on stall is enabled, if configured; Stall output signal (DIAG0/1) is enabled, if configured
#define TMC2240_TCOOLTHRS_SHIFT 0 // This is the lower threshold velocity for switching on smart energy CoolStep and StallGuard feature. (unsigned); Set this parameter to disable CoolStep at low speeds, where it cannot work reliably. The stop on stall function (enable with sg_stop when using internal motion controller) and the stall output signal become enabled when exceeding this velocity. In non-DcStep mode, it becomes disabled again once the velocity falls below this threshold.; TCOOLTHRS = TSTEP = THIGH:; CoolStep is enabled, if configured; TCOOLTHRS = TSTEP; Stop on stall is enabled, if configured; Stall output signal (DIAG0/1) is enabled, if configured
#define TMC2240_THIGH_MASK 0xFFFFF // THIGH // This velocity setting allows velocity dependent switching into a different chopper mode and fullstepping to maximize torque. (unsigned); The stall detection feature becomes switched off for 2-3 electrical periods whenever passing THIGH threshold to compensate for the effect of switching modes.; TSTEP = THIGH:; CoolStep is disabled (motor runs with normal current scale); StealthChop voltage PWM mode is disabled; If vhighchm is set, the chopper switches to chm=1 with TFD=0 (constant off time with slow decay, only).; If vhighfs is set, the motor operates in fullstep mode and the stall detection becomes switched over to DcStep stall detection.
#define TMC2240_THIGH_SHIFT 0 // This velocity setting allows velocity dependent switching into a different chopper mode and fullstepping to maximize torque. (unsigned); The stall detection feature becomes switched off for 2-3 electrical periods whenever passing THIGH threshold to compensate for the effect of switching modes.; TSTEP = THIGH:; CoolStep is disabled (motor runs with normal current scale); StealthChop voltage PWM mode is disabled; If vhighchm is set, the chopper switches to chm=1 with TFD=0 (constant off time with slow decay, only).; If vhighfs is set, the motor operates in fullstep mode and the stall detection becomes switched over to DcStep stall detection.
#define TMC2240_DIRECT_COIL_A_MASK 0x1FF // DIRECT_MODE // When direct mode in GCONF is selected:; Signed coil A current
#define TMC2240_DIRECT_COIL_A_SHIFT 0 // When direct mode in GCONF is selected:; Signed coil A current
#define TMC2240_DIRECT_COIL_B_MASK 0x1FF0000 // DIRECT_MODE // When direct mode in GCONF is selected:; Signed coil B current
#define TMC2240_DIRECT_COIL_B_SHIFT 16 // When direct mode in GCONF is selected:; Signed coil B current
#define TMC2240_POL_A_MASK 0x01 // ENCMODE // Required A polarity for an N channel event
#define TMC2240_POL_A_SHIFT 0 // Required A polarity for an N channel event
#define TMC2240_POL_B_MASK 0x02 // ENCMODE // Required B polarity for an N channel event
#define TMC2240_POL_B_SHIFT 1 // Required B polarity for an N channel event
#define TMC2240_POL_N_MASK 0x04 // ENCMODE // Defines active polarity of N
#define TMC2240_POL_N_SHIFT 2 // Defines active polarity of N
#define TMC2240_IGNORE_AB_MASK 0x08 // ENCMODE // N event configuration
#define TMC2240_IGNORE_AB_SHIFT 3 // N event configuration
#define TMC2240_CLR_CONT_MASK 0x10 // ENCMODE // Position latch configuration
#define TMC2240_CLR_CONT_SHIFT 4 // Position latch configuration
#define TMC2240_CLR_ONCE_MASK 0x20 // ENCMODE // Position latch configuration
#define TMC2240_CLR_ONCE_SHIFT 5 // Position latch configuration
#define TMC2240_POS_NEG_EDGE_MASK 0xC0 // ENCMODE // N channel event sensitivity
#define TMC2240_POS_NEG_EDGE_SHIFT 6 // N channel event sensitivity
#define TMC2240_CLR_ENC_X_MASK 0x100 // ENCMODE // Encoder latch configuration
#define TMC2240_CLR_ENC_X_SHIFT 8 // Encoder latch configuration
#define TMC2240_LATCH_X_ACT_MASK 0x200 // ENCMODE // Position latch configuration
#define TMC2240_LATCH_X_ACT_SHIFT 9 // Position latch configuration
#define TMC2240_ENC_SEL_DECIMAL_MASK 0x400 // ENCMODE // Encoder prescaler mode selection
#define TMC2240_ENC_SEL_DECIMAL_SHIFT 10 // Encoder prescaler mode selection
#define TMC2240_X_ENC_MASK 0xFFFFFFFF // X_ENC // Actual encoder position (signed)
#define TMC2240_X_ENC_SHIFT 0 // Actual encoder position (signed)
#define TMC2240_ENC_CONST_MASK 0xFFFFFFFF // ENC_CONST // Accumulation constant (signed); 16 bit integer part, 16 bit fractional part; X_ENC accumulates; +/- ENC_CONST / (2^16*X_ENC) (binary); or; +/-ENC_CONST / (10^4*X_ENC) (decimal); ENCMODE bit enc_sel_decimal switches between decimal and binary setting.; Use the sign, to match rotation direction!; binary:; ± [µsteps/2^16]; ±(0 …; 32767.999847); decimal:; ±(0.0 … 32767.9999); reset default = 1.0 (=65536)
#define TMC2240_ENC_CONST_SHIFT 0 // Accumulation constant (signed); 16 bit integer part, 16 bit fractional part; X_ENC accumulates; +/- ENC_CONST / (2^16*X_ENC) (binary); or; +/-ENC_CONST / (10^4*X_ENC) (decimal); ENCMODE bit enc_sel_decimal switches between decimal and binary setting.; Use the sign, to match rotation direction!; binary:; ± [µsteps/2^16]; ±(0 …; 32767.999847); decimal:; ±(0.0 … 32767.9999); reset default = 1.0 (=65536)
#define TMC2240_N_EVENT_MASK 0x01 // ENC_STATUS // #type=COW
#define TMC2240_N_EVENT_SHIFT 0 // #type=COW
#define TMC2240_DEVIATION_WARN_MASK 0x02 // ENC_STATUS // #type=COW
#define TMC2240_DEVIATION_WARN_SHIFT 1 // #type=COW
#define TMC2240_ENC_LATCH_MASK 0xFFFFFFFF // ENC_LATCH // Encoder position X_ENC latched on N event
#define TMC2240_ENC_LATCH_SHIFT 0 // Encoder position X_ENC latched on N event
#define TMC2240_ADC_VSUPPLY_MASK 0x1FFF // ADC_VSUPPLY_AIN // Actual Value of voltage on VS (filtered with low pass filter), update rate: each 2048 clocks [als Plan für alle 3 Werte, den Rest schicken wir den ADC ins idle]
#define TMC2240_ADC_VSUPPLY_SHIFT 0 // Actual Value of voltage on VS (filtered with low pass filter), update rate: each 2048 clocks [als Plan für alle 3 Werte, den Rest schicken wir den ADC ins idle]
#define TMC2240_ADC_AIN_MASK 0x1FFF0000 // ADC_VSUPPLY_AIN // Value of voltage on ADC_AIN pin in integer
#define TMC2240_ADC_AIN_SHIFT 16 // Value of voltage on ADC_AIN pin in integer
#define TMC2240_ADC_TEMP_MASK 0x1FFF // ADC_TEMP // Analog voltage on general purpose input AIN [zu klären ist der Range – ggf. 0-1.25V ist m.E. der native Bereich des ADCs]
#define TMC2240_ADC_TEMP_SHIFT 0 // Analog voltage on general purpose input AIN [zu klären ist der Range – ggf. 0-1.25V ist m.E. der native Bereich des ADCs]
#define TMC2240_OVERVOLTAGE_VTH_MASK 0x1FFF // OTW_OV_VTH // Overvoltage threshold for output OV. Default: 38V, 36 V equals 1.125 V at ADC inputs
#define TMC2240_OVERVOLTAGE_VTH_SHIFT 0 // Overvoltage threshold for output OV. Default: 38V, 36 V equals 1.125 V at ADC inputs
#define TMC2240_OVERTEMPPREWARNING_VTH_MASK 0x1FFF0000 // OTW_OV_VTH // Overtemperature warning threshold register:; ADC_TEMP >= OVERTEMPPREWARNING_VTH; Overtemperatureprewarning will be triggered; (Reset: 0xB92 equals 120°C)
#define TMC2240_OVERTEMPPREWARNING_VTH_SHIFT 16 // Overtemperature warning threshold register:; ADC_TEMP >= OVERTEMPPREWARNING_VTH; Overtemperatureprewarning will be triggered; (Reset: 0xB92 equals 120°C)
#define TMC2240_MSLUT_0_MASK 0xFFFFFFFF // MSLUT_0 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table
#define TMC2240_MSLUT_0_SHIFT 0 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table
#define TMC2240_MSLUT_1_MASK 0xFFFFFFFF // MSLUT_1 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_1_SHIFT 0 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_2_MASK 0xFFFFFFFF // MSLUT_2 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_2_SHIFT 0 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_3_MASK 0xFFFFFFFF // MSLUT_3 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_3_SHIFT 0 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_4_MASK 0xFFFFFFFF // MSLUT_4 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_4_SHIFT 0 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_5_MASK 0xFFFFFFFF // MSLUT_5 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_5_SHIFT 0 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_6_MASK 0xFFFFFFFF // MSLUT_6 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_6_SHIFT 0 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_7_MASK 0xFFFFFFFF // MSLUT_7 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_MSLUT_7_SHIFT 0 // Each bit gives the difference between entry x and entry x+1 when combined with the cor­res­ponding MSLUTSEL W bits:; 0: W=; %00: -1; %01: +0; %10: +1; %11: +2; 1: W=; %00: +0; %01: +1; %10: +2; %11: +3; This is the differential coding for the first quarter of a wave. Start values for CUR_A and CUR_B are stored for MSCNT position 0 in START_SIN and START_SIN90.; ofs31, ofs30, …, ofs01, ofs00; …; ofs255, ofs254, …, ofs225, ofs224; reset default= sine wave table; ???????
#define TMC2240_W0_MASK 0x03 // MSLUTSEL // LUT width select from ofs00 to ofs(X1-1); Width control bit coding W0…W3:; %00:; MSLUT entry 0, 1 select: -1, +0; %01:; MSLUT entry 0, 1 select: +0, +1; %10:; MSLUT entry 0, 1 select: +1, +2; %11:; MSLUT entry 0, 1 select: +2, +3
#define TMC2240_W0_SHIFT 0 // LUT width select from ofs00 to ofs(X1-1); Width control bit coding W0…W3:; %00:; MSLUT entry 0, 1 select: -1, +0; %01:; MSLUT entry 0, 1 select: +0, +1; %10:; MSLUT entry 0, 1 select: +1, +2; %11:; MSLUT entry 0, 1 select: +2, +3
#define TMC2240_W1_MASK 0x0C // MSLUTSEL // LUT width select from ofs(X1) to ofs(X2-1); Width control bit coding W0…W3:; %00:; MSLUT entry 0, 1 select: -1, +0; %01:; MSLUT entry 0, 1 select: +0, +1; %10:; MSLUT entry 0, 1 select: +1, +2; %11:; MSLUT entry 0, 1 select: +2, +3
#define TMC2240_W1_SHIFT 2 // LUT width select from ofs(X1) to ofs(X2-1); Width control bit coding W0…W3:; %00:; MSLUT entry 0, 1 select: -1, +0; %01:; MSLUT entry 0, 1 select: +0, +1; %10:; MSLUT entry 0, 1 select: +1, +2; %11:; MSLUT entry 0, 1 select: +2, +3
#define TMC2240_W2_MASK 0x30 // MSLUTSEL // LUT width select from ofs(X2) to ofs(X3-1); Width control bit coding W0…W3:; %00:; MSLUT entry 0, 1 select: -1, +0; %01:; MSLUT entry 0, 1 select: +0, +1; %10:; MSLUT entry 0, 1 select: +1, +2; %11:; MSLUT entry 0, 1 select: +2, +3
#define TMC2240_W2_SHIFT 4 // LUT width select from ofs(X2) to ofs(X3-1); Width control bit coding W0…W3:; %00:; MSLUT entry 0, 1 select: -1, +0; %01:; MSLUT entry 0, 1 select: +0, +1; %10:; MSLUT entry 0, 1 select: +1, +2; %11:; MSLUT entry 0, 1 select: +2, +3
#define TMC2240_W3_MASK 0xC0 // MSLUTSEL // LUT width select from ofs(X3) to ofs255; Width control bit coding W0…W3:; %00:; MSLUT entry 0, 1 select: -1, +0; %01:; MSLUT entry 0, 1 select: +0, +1; %10:; MSLUT entry 0, 1 select: +1, +2; %11:; MSLUT entry 0, 1 select: +2, +3
#define TMC2240_W3_SHIFT 6 // LUT width select from ofs(X3) to ofs255; Width control bit coding W0…W3:; %00:; MSLUT entry 0, 1 select: -1, +0; %01:; MSLUT entry 0, 1 select: +0, +1; %10:; MSLUT entry 0, 1 select: +1, +2; %11:; MSLUT entry 0, 1 select: +2, +3
#define TMC2240_X1_MASK 0xFF00 // MSLUTSEL // LUT segment 1 start; The sine wave look up table can be divided into up to four segments using an individual step width control entry Wx. The segment borders are selected by X1, X2 and X3.; Segment 0 goes from 0 to X1-1.; Segment 1 goes from X1 to X2-1.; Segment 2 goes from X2 to X3-1.; Segment 3 goes from X3 to 255.; For defined response the values shall satisfy:; 0X1X2X3
#define TMC2240_X1_SHIFT 8 // LUT segment 1 start; The sine wave look up table can be divided into up to four segments using an individual step width control entry Wx. The segment borders are selected by X1, X2 and X3.; Segment 0 goes from 0 to X1-1.; Segment 1 goes from X1 to X2-1.; Segment 2 goes from X2 to X3-1.; Segment 3 goes from X3 to 255.; For defined response the values shall satisfy:; 0X1X2X3
#define TMC2240_X2_MASK 0xFF0000 // MSLUTSEL // LUT segment 1 start; The sine wave look up table can be divided into up to four segments using an individual step width control entry Wx. The segment borders are selected by X1, X2 and X3.; Segment 0 goes from 0 to X1-1.; Segment 1 goes from X1 to X2-1.; Segment 2 goes from X2 to X3-1.; Segment 3 goes from X3 to 255.; For defined response the values shall satisfy:; 0X1X2X3
#define TMC2240_X2_SHIFT 16 // LUT segment 1 start; The sine wave look up table can be divided into up to four segments using an individual step width control entry Wx. The segment borders are selected by X1, X2 and X3.; Segment 0 goes from 0 to X1-1.; Segment 1 goes from X1 to X2-1.; Segment 2 goes from X2 to X3-1.; Segment 3 goes from X3 to 255.; For defined response the values shall satisfy:; 0X1X2X3
#define TMC2240_X3_MASK 0xFF000000 // MSLUTSEL // LUT segment 1 start; The sine wave look up table can be divided into up to four segments using an individual step width control entry Wx. The segment borders are selected by X1, X2 and X3.; Segment 0 goes from 0 to X1-1.; Segment 1 goes from X1 to X2-1.; Segment 2 goes from X2 to X3-1.; Segment 3 goes from X3 to 255.; For defined response the values shall satisfy:; 0X1X2X3
#define TMC2240_X3_SHIFT 24 // LUT segment 1 start; The sine wave look up table can be divided into up to four segments using an individual step width control entry Wx. The segment borders are selected by X1, X2 and X3.; Segment 0 goes from 0 to X1-1.; Segment 1 goes from X1 to X2-1.; Segment 2 goes from X2 to X3-1.; Segment 3 goes from X3 to 255.; For defined response the values shall satisfy:; 0X1X2X3
#define TMC2240_START_SIN_MASK 0xFF // MSLUTSTART // START_SIN gives the absolute value at microstep table entry 0.
#define TMC2240_START_SIN_SHIFT 0 // START_SIN gives the absolute value at microstep table entry 0.
#define TMC2240_START_SIN90_MASK 0xFF0000 // MSLUTSTART // START_SIN­90 gives the absolute value for cosine wave microstep table entry at MSCNT=0 (table position 256+OFFSET_SIN90).
#define TMC2240_START_SIN90_SHIFT 16 // START_SIN­90 gives the absolute value for cosine wave microstep table entry at MSCNT=0 (table position 256+OFFSET_SIN90).
#define TMC2240_OFFSET_SIN90_MASK 0xFF000000 // MSLUTSTART // Signed offset for cosine wave +-127 microsteps. Adapt START_SIN90 to match the microstep wave table at position MSCNT=0
#define TMC2240_OFFSET_SIN90_SHIFT 24 // Signed offset for cosine wave +-127 microsteps. Adapt START_SIN90 to match the microstep wave table at position MSCNT=0
#define TMC2240_MSCNT_MASK 0x3FF // MSCNT // Microstep counter. Indicates actual position in the microstep table for CUR_A. CUR_B uses an offset of 256 (2 phase motor).; Hint: Move to a position where MSCNT is zero before re-initializing MSLUTSTART or MSLUT and MSLUTSEL.
#define TMC2240_MSCNT_SHIFT 0 // Microstep counter. Indicates actual position in the microstep table for CUR_A. CUR_B uses an offset of 256 (2 phase motor).; Hint: Move to a position where MSCNT is zero before re-initializing MSLUTSTART or MSLUT and MSLUTSEL.
#define TMC2240_CUR_B_MASK 0x1FF // MSCURACT // Actual microstep current for motor phase B (sine wave) as read from MSLUT (not scaled by current)
#define TMC2240_CUR_B_SHIFT 0 // Actual microstep current for motor phase B (sine wave) as read from MSLUT (not scaled by current)
#define TMC2240_CUR_A_MASK 0x1FF0000 // MSCURACT // Actual microstep current for motor phase A (co-sine wave) as read from MSLUT (not scaled by current)
#define TMC2240_CUR_A_SHIFT 16 // Actual microstep current for motor phase A (co-sine wave) as read from MSLUT (not scaled by current)
#define TMC2240_TOFF_MASK 0x0F // CHOPCONF // TOFF off time and driver enable; Off time setting controls duration of slow decay phase; NCLK= 24 + 32*TOFF; %0000: Driver disable, all bridges off; %0001: 1 – use only with TBL = 2; %0010 … %1111: 2 … 15
#define TMC2240_TOFF_SHIFT 0 // TOFF off time and driver enable; Off time setting controls duration of slow decay phase; NCLK= 24 + 32*TOFF; %0000: Driver disable, all bridges off; %0001: 1 – use only with TBL = 2; %0010 … %1111: 2 … 15
#define TMC2240_HSTRT_TFD210_MASK 0x70 // CHOPCONF // with chm=0; HSTRT; hysteresis start value added to HEND; %000 … %111:; Add 1, 2, …, 8 to hysteresis low value HEND; (1/512 of this setting adds to current setting); Attention: Effective HEND+HSTRT = 16.; Hint: Hysteresis decrement is done each 16 clocks; with chm=1; TFD [2..0]; fast decay time setting; Fast decay time setting (MSB:; fd3):; %0000 … %1111:; Fast decay time setting TFD with; NCLK= 32*TFD (%0000: slow decay only)
#define TMC2240_HSTRT_TFD210_SHIFT 4 // with chm=0; HSTRT; hysteresis start value added to HEND; %000 … %111:; Add 1, 2, …, 8 to hysteresis low value HEND; (1/512 of this setting adds to current setting); Attention: Effective HEND+HSTRT = 16.; Hint: Hysteresis decrement is done each 16 clocks; with chm=1; TFD [2..0]; fast decay time setting; Fast decay time setting (MSB:; fd3):; %0000 … %1111:; Fast decay time setting TFD with; NCLK= 32*TFD (%0000: slow decay only)
#define TMC2240_HEND_OFFSET_MASK 0x780 // CHOPCONF // with chm=0; HEND; hysteresis low value; %0000 … %1111:; Hysteresis is -3, -2, -1, 0, 1, …, 12; (1/512 of this setting adds to current setting); This is the hysteresis value which becomes used for the hysteresis chopper.; with chm=1; OFFSET; sine wave offset; %0000 … %1111:; Offset is -3, -2, -1, 0, 1, …, 12; This is the sine wave offset and 1/512 of the value becomes added to the absolute value of each sine wave entry.
#define TMC2240_HEND_OFFSET_SHIFT 7 // with chm=0; HEND; hysteresis low value; %0000 … %1111:; Hysteresis is -3, -2, -1, 0, 1, …, 12; (1/512 of this setting adds to current setting); This is the hysteresis value which becomes used for the hysteresis chopper.; with chm=1; OFFSET; sine wave offset; %0000 … %1111:; Offset is -3, -2, -1, 0, 1, …, 12; This is the sine wave offset and 1/512 of the value becomes added to the absolute value of each sine wave entry.
#define TMC2240_FD3_MASK 0x800 // CHOPCONF // TFD[3]; with chm=1:; MSB of fast decay time setting TFD
#define TMC2240_FD3_SHIFT 11 // TFD[3]; with chm=1:; MSB of fast decay time setting TFD
#define TMC2240_DISFDCC_MASK 0x1000 // CHOPCONF // fast decay mode; with chm=1:; disfdcc=1 disables current comparator usage for termi­nation of the fast decay cycle
#define TMC2240_DISFDCC_SHIFT 12 // fast decay mode; with chm=1:; disfdcc=1 disables current comparator usage for termi­nation of the fast decay cycle
#define TMC2240_CHM_MASK 0x4000 // CHOPCONF // chopper mode
#define TMC2240_CHM_SHIFT 14 // chopper mode
#define TMC2240_TBL_MASK 0x18000 // CHOPCONF // TBL / blank time select; %00 … %11:; Set comparator blank time to 16, 24, 36 or 54 clocks; Hint: %01 or %10 is recommended for most applications; (Reset Default: OTP %01 or %10)
#define TMC2240_TBL_SHIFT 15 // TBL / blank time select; %00 … %11:; Set comparator blank time to 16, 24, 36 or 54 clocks; Hint: %01 or %10 is recommended for most applications; (Reset Default: OTP %01 or %10)
#define TMC2240_VHIGHFS_MASK 0x40000 // CHOPCONF // high velocity fullstep selection; This bit enables switching to fullstep, when VHIGH is exceeded. Switching takes place only at 45° position. The fullstep target current uses the current value from the microstep table at the 45° position.
#define TMC2240_VHIGHFS_SHIFT 18 // high velocity fullstep selection; This bit enables switching to fullstep, when VHIGH is exceeded. Switching takes place only at 45° position. The fullstep target current uses the current value from the microstep table at the 45° position.
#define TMC2240_VHIGHCHM_MASK 0x80000 // CHOPCONF // high velocity chopper mode; This bit enables switching to chm=1 and fd=0, when VHIGH is exceeded. This way, a higher velocity can be achieved. Can be combined with vhighfs=1. If set, the TOFF setting automatically becomes doubled during high velocity operation in order to avoid doubling of the chopper frequency.
#define TMC2240_VHIGHCHM_SHIFT 19 // high velocity chopper mode; This bit enables switching to chm=1 and fd=0, when VHIGH is exceeded. This way, a higher velocity can be achieved. Can be combined with vhighfs=1. If set, the TOFF setting automatically becomes doubled during high velocity operation in order to avoid doubling of the chopper frequency.
#define TMC2240_TPFD_MASK 0xF00000 // CHOPCONF // passive fast decay time; TPFD allows dampening of motor mid-range resonances.; Passive fast decay time setting controls duration of the fast decay phase inserted after bridge polarity change; NCLK= 128*TPFD; %0000: Disable; %0001 … %1111: 1 … 15
#define TMC2240_TPFD_SHIFT 20 // passive fast decay time; TPFD allows dampening of motor mid-range resonances.; Passive fast decay time setting controls duration of the fast decay phase inserted after bridge polarity change; NCLK= 128*TPFD; %0000: Disable; %0001 … %1111: 1 … 15
#define TMC2240_MRES_MASK 0xF000000 // CHOPCONF // micro step resolution selection; %0000:; Native 256 microstep setting. Normally use this setting with the internal motion controller.; %0001 … %1000:; 128, 64, 32, 16, 8, 4, 2, FULLSTEP; Reduced microstep resolution esp. for STEP/DIR operation.; The resolution gives the number of microstep entries per sine quarter wave.; The driver automatically uses microstep positions which result in a symmetrical wave, when choosing a lower microstep resolution.; step width=2^MRES [microsteps]
#define TMC2240_MRES_SHIFT 24 // micro step resolution selection; %0000:; Native 256 microstep setting. Normally use this setting with the internal motion controller.; %0001 … %1000:; 128, 64, 32, 16, 8, 4, 2, FULLSTEP; Reduced microstep resolution esp. for STEP/DIR operation.; The resolution gives the number of microstep entries per sine quarter wave.; The driver automatically uses microstep positions which result in a symmetrical wave, when choosing a lower microstep resolution.; step width=2^MRES [microsteps]
#define TMC2240_INTPOL_MASK 0x10000000 // CHOPCONF // interpolation to 256 microsteps
#define TMC2240_INTPOL_SHIFT 28 // interpolation to 256 microsteps
#define TMC2240_DEDGE_MASK 0x20000000 // CHOPCONF // enable double edge step pulses
#define TMC2240_DEDGE_SHIFT 29 // enable double edge step pulses
#define TMC2240_DISS2G_MASK 0x40000000 // CHOPCONF // short to GND protection disable
#define TMC2240_DISS2G_SHIFT 30 // short to GND protection disable
#define TMC2240_DISS2VS_MASK 0x80000000 // CHOPCONF // short to supply protection disable
#define TMC2240_DISS2VS_SHIFT 31 // short to supply protection disable
#define TMC2240_SEMIN_MASK 0x0F // COOLCONF // minimum StallGuard2 value for smart current control and; smart current enable; If the StallGuard2 result falls below SEMIN*32, the motor current becomes increased to reduce motor load angle.; %0000: smart current control CoolStep off; %0001 … %1111: 1 … 15
#define TMC2240_SEMIN_SHIFT 0 // minimum StallGuard2 value for smart current control and; smart current enable; If the StallGuard2 result falls below SEMIN*32, the motor current becomes increased to reduce motor load angle.; %0000: smart current control CoolStep off; %0001 … %1111: 1 … 15
#define TMC2240_SEUP_MASK 0x60 // COOLCONF // current up step width; Current increment steps per measured StallGuard2 value; %00 … %11: 1, 2, 4, 8
#define TMC2240_SEUP_SHIFT 5 // current up step width; Current increment steps per measured StallGuard2 value; %00 … %11: 1, 2, 4, 8
#define TMC2240_SEMAX_MASK 0xF00 // COOLCONF // StallGuard2 hysteresis value for smart current control; If the StallGuard2 result is equal to or above (SEMIN+SEMAX+1)*32, the motor current becomes decreased to save energy.; %0000 … %1111: 0 … 15
#define TMC2240_SEMAX_SHIFT 8 // StallGuard2 hysteresis value for smart current control; If the StallGuard2 result is equal to or above (SEMIN+SEMAX+1)*32, the motor current becomes decreased to save energy.; %0000 … %1111: 0 … 15
#define TMC2240_SEDN_MASK 0x6000 // COOLCONF // current down step speed; %00: For each 32 StallGuard2 values decrease by one; %01: For each 8 StallGuard2 values decrease by one; %10: For each 2 StallGuard2 values decrease by one; %11: For each StallGuard2 value decrease by one
#define TMC2240_SEDN_SHIFT 13 // current down step speed; %00: For each 32 StallGuard2 values decrease by one; %01: For each 8 StallGuard2 values decrease by one; %10: For each 2 StallGuard2 values decrease by one; %11: For each StallGuard2 value decrease by one
#define TMC2240_SEIMIN_MASK 0x8000 // COOLCONF // minimum current for smart current control
#define TMC2240_SEIMIN_SHIFT 15 // minimum current for smart current control
#define TMC2240_SGT_MASK 0x7F0000 // COOLCONF // StallGuard2 threshold value; This signed value controls StallGuard2 level for stall output and sets the optimum measurement range for readout. A lower value gives a higher sensitivity. Zero is the starting value working with most motors.; -64 to +63:; A higher value makes StallGuard2 less sensi­tive and requires more torque to indicate a stall.
#define TMC2240_SGT_SHIFT 16 // StallGuard2 threshold value; This signed value controls StallGuard2 level for stall output and sets the optimum measurement range for readout. A lower value gives a higher sensitivity. Zero is the starting value working with most motors.; -64 to +63:; A higher value makes StallGuard2 less sensi­tive and requires more torque to indicate a stall.
#define TMC2240_SFILT_MASK 0x1000000 // COOLCONF // StallGuard2 filter enable
#define TMC2240_SFILT_SHIFT 24 // StallGuard2 filter enable
#define TMC2240_DC_TIME_MASK 0x3FF // DCCTRL // Upper PWM on time limit for commutation (DC_TIME * 1/fCLK). Set slightly above effective blank time TBL.
#define TMC2240_DC_TIME_SHIFT 0 // Upper PWM on time limit for commutation (DC_TIME * 1/fCLK). Set slightly above effective blank time TBL.
#define TMC2240_DC_SG_MASK 0xFF0000 // DCCTRL // Max. PWM on time for step loss detection using DcStep StallGuard2 in DcStep mode. (DC_SG * 16/fCLK); Set slightly higher than DC_TIME/16; 0=disable
#define TMC2240_DC_SG_SHIFT 16 // Max. PWM on time for step loss detection using DcStep StallGuard2 in DcStep mode. (DC_SG * 16/fCLK); Set slightly higher than DC_TIME/16; 0=disable
#define TMC2240_SG_RESULT_MASK 0x3FF // DRV_STATUS // StallGuard2 result respectively StallGuard4 result (depending on actual chopper mode) resp. PWM on time for coil A in stand still with SpreadCycle for motor temperature detection.; Mechanical load measurement:; The StallGuard2/4 result gives a means to measure mecha­nical motor load. A higher value means lower mecha­nical load. For StallGuard2, a value of 0 signals highest load. With opti­mum SGT setting, this is an indicator for a motor stall. The stall detection compares SG_RESULT to 0 in order to detect a stall. SG_RESULT is used as a base for CoolStep operation, by comparing it to a pro­grammable upper and a lower limit. It is not applicable in StealthChop mode.; StallGuard2 works best with microstep operation or DcStep.; Temperature measurement during SpreadCycle mode:; In standstill, no StallGuard2 result can be obtained. SG_RESULT shows the chopper on-time for motor coil A instead. Move the motor to a determined micro­step position at a certain current setting to get a rough estimation of motor temperature by a reading the chopper on-time. As the motor heats up, its coil resistance rises and the chopper on-time increases. For StallGuard4 specifics, please refer SG4_RESULT.
#define TMC2240_SG_RESULT_SHIFT 0 // StallGuard2 result respectively StallGuard4 result (depending on actual chopper mode) resp. PWM on time for coil A in stand still with SpreadCycle for motor temperature detection.; Mechanical load measurement:; The StallGuard2/4 result gives a means to measure mecha­nical motor load. A higher value means lower mecha­nical load. For StallGuard2, a value of 0 signals highest load. With opti­mum SGT setting, this is an indicator for a motor stall. The stall detection compares SG_RESULT to 0 in order to detect a stall. SG_RESULT is used as a base for CoolStep operation, by comparing it to a pro­grammable upper and a lower limit. It is not applicable in StealthChop mode.; StallGuard2 works best with microstep operation or DcStep.; Temperature measurement during SpreadCycle mode:; In standstill, no StallGuard2 result can be obtained. SG_RESULT shows the chopper on-time for motor coil A instead. Move the motor to a determined micro­step position at a certain current setting to get a rough estimation of motor temperature by a reading the chopper on-time. As the motor heats up, its coil resistance rises and the chopper on-time increases. For StallGuard4 specifics, please refer SG4_RESULT.
#define TMC2240_S2VSA_MASK 0x1000 // DRV_STATUS // short to supply indicator phase A
#define TMC2240_S2VSA_SHIFT 12 // short to supply indicator phase A
#define TMC2240_S2VSB_MASK 0x2000 // DRV_STATUS // short to supply indicator phase B
#define TMC2240_S2VSB_SHIFT 13 // short to supply indicator phase B
#define TMC2240_STEALTH_MASK 0x4000 // DRV_STATUS // StealthChop indicator
#define TMC2240_STEALTH_SHIFT 14 // StealthChop indicator
#define TMC2240_FSACTIVE_MASK 0x8000 // DRV_STATUS // full step active indicator
#define TMC2240_FSACTIVE_SHIFT 15 // full step active indicator
#define TMC2240_CS_ACTUAL_MASK 0x1F0000 // DRV_STATUS // actual motor current / smart energy current; Actual current control scaling, for monitoring smart energy current scaling controlled via settings in register COOLCONF, or for monitoring the function of the automatic current scaling
#define TMC2240_CS_ACTUAL_SHIFT 16 // actual motor current / smart energy current; Actual current control scaling, for monitoring smart energy current scaling controlled via settings in register COOLCONF, or for monitoring the function of the automatic current scaling
#define TMC2240_STALLGUARD_MASK 0x1000000 // DRV_STATUS // StallGuard2/StallGuard4 status
#define TMC2240_STALLGUARD_SHIFT 24 // StallGuard2/StallGuard4 status
#define TMC2240_OT_MASK 0x2000000 // DRV_STATUS // overtemperature flag
#define TMC2240_OT_SHIFT 25 // overtemperature flag
#define TMC2240_OTPW_MASK 0x4000000 // DRV_STATUS // overtemperature pre-warning flag
#define TMC2240_OTPW_SHIFT 26 // overtemperature pre-warning flag
#define TMC2240_S2GA_MASK 0x8000000 // DRV_STATUS // short to ground indicator phase A
#define TMC2240_S2GA_SHIFT 27 // short to ground indicator phase A
#define TMC2240_S2GB_MASK 0x10000000 // DRV_STATUS // short to ground indicator phase B
#define TMC2240_S2GB_SHIFT 28 // short to ground indicator phase B
#define TMC2240_OLA_MASK 0x20000000 // DRV_STATUS // open load indicator phase A
#define TMC2240_OLA_SHIFT 29 // open load indicator phase A
#define TMC2240_OLB_MASK 0x40000000 // DRV_STATUS // open load indicator phase B
#define TMC2240_OLB_SHIFT 30 // open load indicator phase B
#define TMC2240_STST_MASK 0x80000000 // DRV_STATUS // standstill indicator; This flag indicates motor stand still in each operation mode. This occurs 2^20 clocks after the last step pulse.
#define TMC2240_STST_SHIFT 31 // standstill indicator; This flag indicates motor stand still in each operation mode. This occurs 2^20 clocks after the last step pulse.
#define TMC2240_PWM_OFS_MASK 0xFF // PWMCONF // User defined PWM amplitude offset (0-255) related to full motor current (CS_ACTUAL=31) in stand still.; (Reset default=30); Use PWM_OFS as initial value for automatic scaling to speed up the automatic tuning process. To do this, set PWM_OFS to the determined, application specific value, with pwm_autoscale=0. Only afterwards, set pwm_autoscale=1. Enable StealthChop when finished.; PWM_OFS = 0 will disable scaling down motor current below a motor specific lower measurement threshold. This setting should only be used under certain conditions, i.e. when the power supply voltage can vary up and down by a factor of two or more. It prevents the motor going out of regulation, but it also prevents power down below the regulation limit.; PWM_OFS > 0 allows automatic scaling to low PWM duty cycles even below the lower regulation threshold. This allows low (standstill) current settings based on the actual (hold) current scale (register IHOLD_IRUN).
#define TMC2240_PWM_OFS_SHIFT 0 // User defined PWM amplitude offset (0-255) related to full motor current (CS_ACTUAL=31) in stand still.; (Reset default=30); Use PWM_OFS as initial value for automatic scaling to speed up the automatic tuning process. To do this, set PWM_OFS to the determined, application specific value, with pwm_autoscale=0. Only afterwards, set pwm_autoscale=1. Enable StealthChop when finished.; PWM_OFS = 0 will disable scaling down motor current below a motor specific lower measurement threshold. This setting should only be used under certain conditions, i.e. when the power supply voltage can vary up and down by a factor of two or more. It prevents the motor going out of regulation, but it also prevents power down below the regulation limit.; PWM_OFS > 0 allows automatic scaling to low PWM duty cycles even below the lower regulation threshold. This allows low (standstill) current settings based on the actual (hold) current scale (register IHOLD_IRUN).
#define TMC2240_PWM_GRAD_MASK 0xFF00 // PWMCONF // Velocity dependent gradient for PWM amplitude:; PWM_GRAD * 256 / TSTEP; This value is added to PWM_OFS to compensate for the velocity-dependent motor back-EMF.; Use PWM_GRAD as initial value for automatic scaling to speed up the automatic tuning process. To do this, set PWM_GRAD to the determined, application specific value, with pwm_autoscale=0. Only afterwards, set pwm_autoscale=1. Enable StealthChop when finished.; Hint:; After initial tuning, the required initial value can be read out from PWM_GRAD_AUTO.
#define TMC2240_PWM_GRAD_SHIFT 8 // Velocity dependent gradient for PWM amplitude:; PWM_GRAD * 256 / TSTEP; This value is added to PWM_OFS to compensate for the velocity-dependent motor back-EMF.; Use PWM_GRAD as initial value for automatic scaling to speed up the automatic tuning process. To do this, set PWM_GRAD to the determined, application specific value, with pwm_autoscale=0. Only afterwards, set pwm_autoscale=1. Enable StealthChop when finished.; Hint:; After initial tuning, the required initial value can be read out from PWM_GRAD_AUTO.
#define TMC2240_PWM_FREQ_MASK 0x30000 // PWMCONF // PWM frequency selection:; %00:; fPWM=2/1024 fCLK (Reset default); %01:; fPWM=2/683 fCLK; %10:; fPWM=2/512 fCLK; %11:; fPWM=2/410 fCLK
#define TMC2240_PWM_FREQ_SHIFT 16 // PWM frequency selection:; %00:; fPWM=2/1024 fCLK (Reset default); %01:; fPWM=2/683 fCLK; %10:; fPWM=2/512 fCLK; %11:; fPWM=2/410 fCLK
#define TMC2240_PWM_AUTOSCALE_MASK 0x40000 // PWMCONF // PWM automatic amplitude scaling
#define TMC2240_PWM_AUTOSCALE_SHIFT 18 // PWM automatic amplitude scaling
#define TMC2240_PWM_AUTOGRAD_MASK 0x80000 // PWMCONF // PWM automatic gradient adaptation
#define TMC2240_PWM_AUTOGRAD_SHIFT 19 // PWM automatic gradient adaptation
#define TMC2240_FREEWHEEL_MASK 0x300000 // PWMCONF // Allows different standstill modes; Stand still option when motor current setting is zero (I_HOLD=0).; %00:; Normal operation; %01:; Freewheeling; %10:; Coil shorted using LS drivers; %11:; Coil shorted using HS drivers
#define TMC2240_FREEWHEEL_SHIFT 20 // Allows different standstill modes; Stand still option when motor current setting is zero (I_HOLD=0).; %00:; Normal operation; %01:; Freewheeling; %10:; Coil shorted using LS drivers; %11:; Coil shorted using HS drivers
#define TMC2240_PWM_MEAS_SD_ENABLE_MASK 0x400000 // PWMCONF // Default=0; 1: Uses slow decay phases on low side to measure the motor current to reduce the lower current limit.
#define TMC2240_PWM_MEAS_SD_ENABLE_SHIFT 22 // Default=0; 1: Uses slow decay phases on low side to measure the motor current to reduce the lower current limit.
#define TMC2240_PWM_DIS_REG_STST_MASK 0x800000 // PWMCONF // 1= Disable current regulation when motor is in standstill and current is reduced (less than IRUN). This option eliminates any regulation noise during standstill.
#define TMC2240_PWM_DIS_REG_STST_SHIFT 23 // 1= Disable current regulation when motor is in standstill and current is reduced (less than IRUN). This option eliminates any regulation noise during standstill.
#define TMC2240_PWM_REG_MASK 0xF000000 // PWMCONF // Regulation loop gradient; User defined maximum PWM amplitude change per half wave when using pwm_autoscale=1. (1…15):; 1: 0.5 increments (slowest regulation); 2: 1 increment; 3: 1.5 increments; 4: 2 increments (Reset default)); …; 8: 4 increments; ...; 15: 7.5 increments (fastest regulation)
#define TMC2240_PWM_REG_SHIFT 24 // Regulation loop gradient; User defined maximum PWM amplitude change per half wave when using pwm_autoscale=1. (1…15):; 1: 0.5 increments (slowest regulation); 2: 1 increment; 3: 1.5 increments; 4: 2 increments (Reset default)); …; 8: 4 increments; ...; 15: 7.5 increments (fastest regulation)
#define TMC2240_PWM_LIM_MASK 0xF0000000 // PWMCONF // PWM automatic scale amplitude limit when switching on; Limit for PWM_SCALE_AUTO when switching back from SpreadCycle to StealthChop. This value defines the upper limit for bits 7 to 4 of the automatic current control when switching back. It can be set to reduce the current jerk during mode change back to StealthChop.; It does not limit PWM_GRAD or PWM_GRAD_AUTO offset.; (Default = 12)
#define TMC2240_PWM_LIM_SHIFT 28 // PWM automatic scale amplitude limit when switching on; Limit for PWM_SCALE_AUTO when switching back from SpreadCycle to StealthChop. This value defines the upper limit for bits 7 to 4 of the automatic current control when switching back. It can be set to reduce the current jerk during mode change back to StealthChop.; It does not limit PWM_GRAD or PWM_GRAD_AUTO offset.; (Default = 12)
#define TMC2240_PWM_SCALE_SUM_MASK 0x3FF // PWM_SCALE // Bits: 9...0: [0...1023]PWM_SCALE_SUM: Actual PWM duty cycle. This value is used for scaling the values CUR_A and CUR_B read from the sine wave table. 1023: maximum duty cycle. This value is extended by two bits [1,0] for higher precision of duty cycle read out. Bits 9..2 correspond to the 8 bit values in other PWM duty cycle related registers.
#define TMC2240_PWM_SCALE_SUM_SHIFT 0 // Bits: 9...0: [0...1023]PWM_SCALE_SUM: Actual PWM duty cycle. This value is used for scaling the values CUR_A and CUR_B read from the sine wave table. 1023: maximum duty cycle. This value is extended by two bits [1,0] for higher precision of duty cycle read out. Bits 9..2 correspond to the 8 bit values in other PWM duty cycle related registers.
#define TMC2240_PWM_SCALE_AUTO_MASK 0x1FF0000 // PWM_SCALE // PWM_SCALE_AUTO
#define TMC2240_PWM_SCALE_AUTO_SHIFT 16 // PWM_SCALE_AUTO
#define TMC2240_PWM_OFS_AUTO_MASK 0xFF // PWM_AUTO // Automatically determined offset value
#define TMC2240_PWM_OFS_AUTO_SHIFT 0 // Automatically determined offset value
#define TMC2240_PWM_GRAD_AUTO_MASK 0xFF0000 // PWM_AUTO // Automatically determined gradient value
#define TMC2240_PWM_GRAD_AUTO_SHIFT 16 // Automatically determined gradient value
#define TMC2240_SG4_THRS_MASK 0xFF // SG4_THRS // Detection threshold for stall. The StallGuard4 value SG4_RESULT becomes compared to the double of this threshold.; A stall is signaled with; SG_RESULT = SG4_THRS*2
#define TMC2240_SG4_THRS_SHIFT 0 // Detection threshold for stall. The StallGuard4 value SG4_RESULT becomes compared to the double of this threshold.; A stall is signaled with; SG_RESULT = SG4_THRS*2
#define TMC2240_SG4_FILT_EN_MASK 0x100 // SG4_THRS // 1: enable SG4 filter, 0: disable SG4 filter
#define TMC2240_SG4_FILT_EN_SHIFT 8 // 1: enable SG4 filter, 0: disable SG4 filter
#define TMC2240_SG_ANGLE_OFFSET_MASK 0x200 // SG4_THRS // 1: Automatic phase shift compensation based on StallGuard4, when switching from StealthChop to SpreadCycle controlled via TPWMTHRS
#define TMC2240_SG_ANGLE_OFFSET_SHIFT 9 // 1: Automatic phase shift compensation based on StallGuard4, when switching from StealthChop to SpreadCycle controlled via TPWMTHRS
#define TMC2240_SG4_RESULT_MASK 0x3FF // SG4_RESULT // StallGuard result for StallGuard4, only.; .; SG4_RESULT becomes updated with each fullstep, independent of TCOOLTHRS and SG4THRS. A higher value signals a lower motor load and more torque headroom.; Intended for StealthChop mode, only. Bits 9 and 0 will always show 0. Scaling to 10 bit is for compatibility to StallGuard2.
#define TMC2240_SG4_RESULT_SHIFT 0 // StallGuard result for StallGuard4, only.; .; SG4_RESULT becomes updated with each fullstep, independent of TCOOLTHRS and SG4THRS. A higher value signals a lower motor load and more torque headroom.; Intended for StealthChop mode, only. Bits 9 and 0 will always show 0. Scaling to 10 bit is for compatibility to StallGuard2.
#define TMC2240_SG4_IND_0_MASK 0xFF // SG4_IND // displays SG4 measurement; When SG4_filt_en = 1:; Displays SG4 measurement 0 used as filter input
#define TMC2240_SG4_IND_0_SHIFT 0 // displays SG4 measurement; When SG4_filt_en = 1:; Displays SG4 measurement 0 used as filter input
#define TMC2240_SG4_IND_1_MASK 0xFF00 // SG4_IND // When SG4_filt_en = 1:; Displays SG4 measurement 1 used as filter input
#define TMC2240_SG4_IND_1_SHIFT 8 // When SG4_filt_en = 1:; Displays SG4 measurement 1 used as filter input
#define TMC2240_SG4_IND_2_MASK 0xFF0000 // SG4_IND // When SG4_filt_en = 1:; Displays SG4 measurement 2 used as filter input
#define TMC2240_SG4_IND_2_SHIFT 16 // When SG4_filt_en = 1:; Displays SG4 measurement 2 used as filter input
#define TMC2240_SG4_IND_3_MASK 0xFF000000 // SG4_IND // When SG4_filt_en = 1:; Displays SG4 measurement 3 used as filter input
#define TMC2240_SG4_IND_3_SHIFT 24 // When SG4_filt_en = 1:; Displays SG4 measurement 3 used as filter input


#endif /* TMC2240_FIELDS_H */
